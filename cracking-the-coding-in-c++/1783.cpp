// 백준 온라인 저지 1783번 https://www.acmicpc.net/problem/1783
// 제한 시간 : 2초
// 실행 시간 : 0ms

// 방문할 수 있는 칸의 최대 개수

#include <iostream>
#include <vector>
using namespace std;

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int N, M;
	cin >> N >> M;

	// vector<vector<int>> board(N, vector<int>(M));

	// 이동 횟수가 4번 이상이고, 이동 방법 4가지 조건에 모두 충족하면,
	if (N >= 3 && M >=7)
	{
		// 이동 방법 4가지를 적어도 한 번씩 이용해 이동
		
		/*2칸 위로, 1칸 오른쪽
		1칸 위로, 2칸 오른쪽
		1칸 아래로, 2칸 오른쪽
		2칸 아래로, 1칸 오른쪽*/
		M -= 6;

		// 위 조건에 따라 4번 이동 후, 남은 칸을 이동
		cout << M + 4;
	}
	// 이동 횟수가 4번 미만이면,
	else
	{
		// 이동 방법 4가지를 모두 사용하지는 않아도 됨.

		// N이 1인 경우, 2인 경우, 3이상인 경우를 나눠 생각
		// ∵ 병든 나이트는 위/아래로 움직일 수 있어 같은 행으로 다시 돌아올 수 있음.

		// N이 1이면,
		if (N == 1)
		{
			// 시작 지점만 방문 가능
			cout << 1;

			return 0;
		}
		// N이 2이면,
		else if (N == 2)
		{
			// 1칸 위/아래로만 가능 ∴ 오른쪽만 고려하면 됨.
			// 위/아래 1칸이면, 오른쪽은 2칸 이동임으로
			// M / 2의 값 + 1(시작 지점)이 방문할 수 있는 최대 칸의 개수

			// 이동 횟수가 4 이상이되면,
			if (M >= 9)
			{
				// N이 2이기 때문에 이동 방법을 모두 한 번씩 사용할 수 없으므로
				// 이동 횟수의 최대는 3, 방문할 수 있는 칸의 최대 개수는 4이다.
				cout << 4;

				return 0;
			}

			if (M % 2 == 1)
			{
				
				cout << M / 2 + 1;
			}
			else
			{
				cout << M / 2;
			}
		}
		// N이 3 이상이고, M이 6 이하이면,
		else
		{
			// 1칸, 2칸 위/아래 모두 가능
			// 왼쪽으로는 이동할 수 없으므로, 오른쪽의 최소 이동 칸수인 1칸을 이용 ∴ 위/아래 2칸, 오른쪽 1칸 이동

			if (M >= 5)
			{
				cout << 4;
			}
			else
			{
				cout << M;
			}
		}
	}
}